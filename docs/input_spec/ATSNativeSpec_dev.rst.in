ATS Native XML Input Specification V1
#######################################

.. contents:: **Table of Contents**

  
Syntax of the Specification
#######################################

* Input specification for each ParameterList entry consists of two parts.  
  First, a bulleted list defines the usage syntax and available options.  
  This is followed by example snipets of XML code to demonstrate usage.

* In many cases, the input specifies data for a particular parameterized model, and ATS 
  supports a number of parameterizations.  
  For example, initial data might be uniform (the value is required), or linear in y (the value 
  and its gradient are required).  
  Where ATS supports a number of parameterized models for quantity Z, the available 
  models will be listed by name, and then will be described in the subsequent section.  
  For example, the specification for an `"X`" list might begin with the following:

  * `"Y`" ``[string]`` **"default_value"**, `"other`", `"valid`", `"options`"

  * Z ``[Z-spec]`` Model for Z, choose exactly one of the following: (1) `"z1`", or (2) `"z2`" (see below) 

Here, an `"X`" is defined by a `"Y`" and a `"Z`".  
The `"Y`" is a string parameter but the `"Z`" is given by a model (which will require its own set of parameters).
The options for `"Z`" will then be described as a spec:

 * `"z1`" applies model z1.  Requires `"z1a`" ``[string]``

 * `"z2`" applies model z2.  Requires `"z2a`" ``[double]`` and `"z2b`" ``[int]``

An example of using such a specification:

.. code-block:: xml

    <ParameterList name="X">
      <Parameter name="Y" type="string" value="hello"/>
      <ParameterList name="z2">
        <Parameter name="z2a" type="double" value="0.7"/>
        <Parameter name="z2b" type="int" value="3"/>
      </ParameterList>   
    </ParameterList>   
 
Here, the user is defining X with Y="hello", and Z will be a z2 constructed with z2a=0.7 and z2b=3.

Conventions:

* Reserved keywords and labels are `"quoted and italicized`" -- these
  labels or values of parameters in user-generated input files must
  match (using XML matching rules) the specified or allowable values.

* User-defined labels are indicated with ALL-CAPS, and are meant to
  represent a typical name given by a user - these can be names or
  numbers or whatever serves best the organization of the user input
  data.

* Bold values are default values, and are used if the Parameter
  is not provided.


Symbol Index
#############

:math:`|E|` | volume of a cell :math:`[m^X]` (where :math:`X` is the dimension of the mesh)
:math:`h` | ponded depth, or the water head over the surface :math:`[m]`
:math:`` | alternative, in context of the subsurface, water head :math:`[m]`
:math:`h_{{snow}}` | snow depth :math:`[m]`
:math:`n_X` | molar density of phase X :math:`[mol m^-3]`
:math:`P_{{\{s,r\}}}` | precipitation of rain or snow, noting that snow is always a precipitation rate in snow-water-equivalent (SWE) basis.  :math:`[m s^-1]`
:math:`s_X` | saturation of phase X :math:`[-]`
:math:`z` | elevation :math:`[m]`
:math:`\phi` | porosity of the soil :math:`[-]`
:math:`\rho` | mass density of a phase :math:`[kg m^-3]`
:math:`\Theta` | extensive water content of a cell :math:`[mol]`

   

  
Main
#######################################

The `"main`" ParameterList frames the entire input spec, and must contain
one sublist for each of the following sections.

* `"mesh`" ``[mesh-spec]``  See the Mesh_ spec.

* `"regions`" ``[list]``

  List of multiple Region_ specs, each in its own sublist named uniquely by the user.

* `"coordinator`" ``[coordinator-spec]``  See the Coordinator_ spec.

* `"visualization`" ``[visualization-spec]`` A Visualization_ spec for the main mesh/domain.

* `"visualization XX`" ``[visualization-spec]``

  Potentially more than one other Visualization_ specs, one for each domain `"XX`".  e.g. `"surface`"

* `"checkpoint`" ``[checkpoint-spec]`` A Checkpoint_ spec.

* `"observations`" ``[observation-spec]`` An Observation_ spec.

* `"PKs`" ``[list]``

  A list containing exactly one sublist, a PK_ spec with the top level PK.

* `"state`" ``[list]`` A State_ spec.

  
Mesh
#####

{ ats_mesh_factory }


Region
##########


{ Region }


Point
======
{ RegionPoint }

Box
======
{ RegionBox }

Plane
======
{ RegionPlane }

Labeled Set
============
{ RegionLabeledSet }

Color Function
===============
{ RegionColorFunction }


Coordinator
############

{ coordinator }
   

Visualization
##############

A user may request periodic writes of field data for the purposes of
visualization in the `"visualization`" sublists.  ATS accepts a visualization
list for each domain/mesh, including surface and column meshes.  These are in
separate ParameterLists, entitled `"visualization`" for the main mesh, and
`"visualization surface`" on the surface mesh.  It is expected that, for any
addition meshes, each will have a domain name and therefore admit a spec of
the form: `"visualization DOMAIN-NAME`".

{ Visualization }

  
Checkpoint
##############

A user may request periodic dumps of ATS Checkpoint Data in the
`"checkpoint`" sublist.  The user has no explicit control over the
content of these files, but has the guarantee that the ATS run will be
reproducible (with accuracies determined by machine round errors and
randomness due to execution in a parallel computing environment).
Therefore, output controls for Checkpoint Data are limited to file
name generation and writing frequency, by numerical cycle number.
Unlike `"visualization`", there is only one `"checkpoint`" list for
all domains/meshes.

The checkpoint-spec includes all parameters as in a IOEvent_ spec and additionally:

* `"file name base`" ``[string]`` **"checkpoint"**
  
* `"file name digits`" ``[int]`` **5**

Example:

.. code-block:: xml

  <ParameterList name="checkpoint">
    <Parameter name="cycles start period stop" type="Array(int)" value="{{0, 100, -1}}" />
    <Parameter name="cycles" type="Array(int)" value="{{999, 1001}}" />
    <Parameter name="times start period stop 0" type="Array(double)" value="{{0.0, 10.0, 100.0}}"/>
    <Parameter name="times start period stop 1" type="Array(double)" value="{{100.0, 25.0, -1.0}}"/>
    <Parameter name="times" type="Array(double)" value="{{101.0, 303.0, 422.0}}"/>
  </ParameterList>

In this example, checkpoint files are written when the cycle number is
a multiple of 100, every 10 seconds for the first 100 seconds, and
every 25 seconds thereafter, along with times 101, 303, and 422.  Files will be written in the form: `"checkpoint00000.h5`".


 
Observation
##############

**This is not currently correct!**

A user may request any number of specific observations from ATS.  Each labeled Observation Data quantity involves a field quantity, a model, a region from which it will extract its source data, and a list of discrete times 
for its evaluation.  The observations are evaluated during the simulation and returned to the calling process through one of ATS arguments.

* `"Observation Data`" [list] can accept multiple lists for named observations (OBSERVATION)

 * `"Observation Output Filename`" [string] user-defined name for the file that the observations are written to.

 * OBSERVATION [list] user-defined label, can accept values for `"Variables`", `"Functional`", `"Region`", and all IOEvent_ spec options.

  * `"Variables`" [Array(string)] a list of field quantities taken from the list of available field quantities:

   * Volumetric water content [volume water / bulk volume]
   * Aqueous saturation [volume water / volume pore space]
   * Aqueous pressure [Pa]
   * Hydraulic Head [m] 
   * XXX Aqueous concentration [moles of solute XXX / volume water in MKS] (name formed by string concatenation, given the definitions in `"Phase Definition`" section)
   * X-, Y-, Z- Aqueous volumetric fluxe [m/s]
   * MaterialID

  * `"Functional`" [string] the label of a function to apply to each of the variables in the variable list (Function options detailed below)

  * `"Region`" [string] the label of a user-defined region

The following Observation Data functionals are currently supported.  All of them operate on the variables identified.

* `"Observation Data: Point`" returns the value of the field quantity at a point

* `"Observation Data: Integral`" returns the integral of the field quantity over the region specified


Example:

.. code-block:: xml

  <ParameterList name="Observation Data">
    <Parameter name="Observation Output Filename" type="string" value="obs_output.out"/>
    <ParameterList name="some observation name">
      <Parameter name="Region" type="string" value="some point region name"/>
      <Parameter name="Functional" type="string" value="Observation Data: Point"/>
      <Parameter name="Variable" type="string" value="Volumetric water content"/>
      <Parameter name="times" type="Array(double)" value="{{100000.0, 200000.0}}"/>

      <Parameter name="cycles" type="Array(int)" value="{{100000, 200000, 400000, 500000}}"/>
      <Parameter name="cycles start period stop" type="Array(int)" value="{{0, 100, -1}}" />

      <Parameter name="times start period stop 0" type="Array(double)" value="{{0.0, 10.0, 100.0}}"/>
      <Parameter name="times start period stop 1" type="Array(double)" value="{{100.0, 25.0, -1.0}}"/>
      <Parameter name="times" type="Array(double)" value="{{101.0, 303.0, 422.0}}"/>

    </ParameterList>
  </ParameterList>



PK
#####

The `"PKs`" ParameterList in Main_ is expected to have one and only one sublist, which corresponds to the PK at the top of the PK tree.
This top level PK is also often an MPC (MPCs are PKs).

All PKs have the following parameters in their spec:

* `"PK type`" ``[string]``

  The PK type is a special key-word which corresponds to a given class in the PK factory.  See available PK types listed below in the `Physical PKs`_ section.

* `"PK name`" ``[string]`` **LIST-NAME**

  This is automatically written as the `"name`" attribute of the containing PK sublist, and need not be included by the user.

Example:

.. code-block:: xml

  <ParameterList name="PKs">
    <ParameterList name="my cool PK">
      <Parameter name="PK type" type="string" value="my cool PK"/>
       ...
    </ParameterList>
  </ParameterList>

.. code-block:: xml

  <ParameterList name="PKs">
    <ParameterList name="Top level MPC">
      <Parameter name="PK type" type="string" value="strong MPC"/>
       ...
    </ParameterList>
  </ParameterList>

Each PK, which may be named arbitrarily, is one of the following PK specs listed below.


Base PKs
===============

There are several types of PKs, and each PK has its own valid input spec.  However, there are three main types of PKs, from which nearly all PKs derive.  Note that none of these are true PKs and cannot stand alone.


PKDefaultBase
----------------

``PKDefaultBase`` is not a true PK, but is a helper for providing some basic functionality shared by (nearly) all PKs.
Therefore, (nearly) all PKs inherit from this base class.  No input required.

PKPhysicalBase
----------------

``PKPhysicalBase (v)-->`` PKDefaultBase_

``PKPhysicalBase`` is a base class providing some functionality for PKs which are defined on a single mesh, and represent a single process model.
Typically all leaves of the PK tree will inherit from ``PKPhysicalBase``.

* `"domain`" ``[string]`` **""**, e.g. `"surface`".

  Domains and meshes are 1-to-1, and the empty string refers to the main domain or mesh.  PKs defined on other domains must specify which domain/mesh they refer to.

* `"primary variable key`" ``[string]``

  The primary variable associated with this PK, i.e. `"pressure`", `"temperature`", `"surface_pressure`", etc.

* `"initial condition`" ``[initial-condition-spec]``  See InitialConditions_.

  Additionally, the following parameters are supported:

 - `"initialize faces from cell`" ``[bool]`` **false**

   Indicates that the primary variable field has both CELL and FACE objects, and the FACE values are calculated as the average of the neighboring cells.

 - other, PK-specific additions


PKBDFBase
----------------

``PKBDFBase  (v)-->`` PKDefaultBase_

``PKBDFBase`` is a base class from which PKs that want to use the ``BDF`` series of implicit time integrators must derive.  It specifies both the ``BDFFnBase`` interface and implements some basic functionality for ``BDF`` PKs.  

* `"initial time step`" ``[double]`` **1.**

  The initial timestep size for the PK, this ensures that the initial timestep will not be **larger** than this value.

* `"assemble preconditioner`" ``[bool]`` **true** 

  A flag for the PK to not assemble its preconditioner if it is not needed by a controlling PK.  This is usually set by the MPC, not by the user.

In the top-most (in the PK tree) PK that is meant to be integrated implicitly, several additional specs are included.  For instance, in a strongly coupled flow and energy problem, these specs are included in the ``StrongMPC`` that couples the flow and energy PKs, not to the flow or energy PK itself.
  
* `"time integrator`" ``[time-integrator-spec]`` is a TimeIntegrator_.

  Note that this is only provided in the top-most ``PKBDFBase`` in the tree -- this is often a StrongMPC_ or a class deriving from StrongMPC_, not a PKPhysicalBDFBase_.

* `"preconditioner`" ``[preconditioner-spec]`` is a Preconditioner_.

  This spec describes how to form the (approximate) inverse of the preconditioner.



PKPhysicalBDFBase
-------------------

``PKPhysicalBDFBase -->`` PKBDFBase_
``PKPhysicalBDFBase -->`` PKPhysicalBase_
``PKPhysicalBDFBase (v)-->`` PKDefaultBase_

A base class for all PKs that are all of the above.

* `"debug cells`" [Array(int)]

  List of global cell IDs for which (if the verbosity is set high enough) more debugging info is printed to the log file.

* `"absolute error tolerance`" [double] **1.0**

  Absolute tolerance, :math:`a_tol` in the equation below.

* `"relative error tolerance`" [double] **1.0**

  Relative tolerance, :math:`r_tol` in the equation below.

By default, the error norm used by solvers is given by:
:math:`ENORM(u, du) = |du| / ( a_tol + r_tol * |u| )`


Physical PKs
===============

Physical PKs are the physical capability implemented within ATS.

Flow PKs
-----------

Richards PK
^^^^^^^^^^^^^^^

Permafrost Flow PK
^^^^^^^^^^^^^^^^^^^^

Overland Flow, head primary variable PK
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Overland Flow, pressure primary variable, PK
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Snow Distribution PK
^^^^^^^^^^^^^^^^^^^^


Energy PKs
-----------

Advection Diffusion PK
^^^^^^^^^^^^^^^^^^^^^^^

Energy Base PK
^^^^^^^^^^^^^^^^^^^^^^^

Two-Phase subsurface Energy PK
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Three-Phase subsurface Energy PK
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Three-Phase subsurface Energy PK
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Surface Ice Energy PK
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



Surface Energy Balance PKs
------------------------------


Surface Energy Balance / Snow -- Monolithic Version
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



Surface Energy Balance -- Generic Version
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



Biogeochemistry
-----------------


Biogeochemistry -- Monolithic Version
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



Deformation
-------------


Volumetric Deformation
^^^^^^^^^^^^^^^^^^^^^^



MPCs
===============

MPCs couple other PKs, and are the non-leaf nodes in the PK tree.

WeakMPC
----------

StrongMPC
----------

Physical MPCs
===============
 coupling is an art, and requires special off-diagonal work.  Physical MPCs can derive from default MPCs to provide special work.

Coupled Water MPC
--------------------


Subsurface MPC
--------------------

Permafrost MPC
--------------------


State
##############

State consists of two sublists, one for evaluators and the other for
atomic constants.  The latter is currently called `"initial
conditions`", which is a terrible name which must be fixed.

example:

.. code-block:: xml
                
  <ParameterList name="state">
    <ParameterList name="field evaluators">
      ...
    </ParameterList>
    <ParameterList name="initial conditions">
      ...
    </ParameterList>
  </ParameterList>
 

Field Evaluators
=================

Many field evaluators exist, but most derive from one of four base types.

Field Evaluator Base Classes
-------------------------------

PrimaryVariableEvaluator
^^^^^^^^^^^^^^^^^^^^^^^^^^^

SecondaryVariableEvaluator
^^^^^^^^^^^^^^^^^^^^^^^^^^^

SecondaryVariablesEvaluator
^^^^^^^^^^^^^^^^^^^^^^^^^^^

IndependentVariableEvaluator
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

While these provide base functionality, all of the physics are in the
following derived classes.

Water Content
-----------------

Water content is the conserved quantity in most flow equations, including
Richard's equation with and without ice.  A variety of evaluators are provided
for inclusion of multiple phases.

RichardsWaterContentEvaluator
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
{ richards_water_content_evaluator }
RichardsWaterContentWithVaporEvaluator
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
{ richards_water_content_with_vapor_evaluator }
PermafrostWaterContentEvaluator
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
{ permafrost_water_content }


Surface Water potential surfaces
---------------------------------

Evaluators for 

SurfaceElevation
^^^^^^^^^^^^^^^^^^
{ meshed_elevation_evaluator }

SurfacePotential
^^^^^^^^^^^^^^^^^^^
{ pres_elev_evaluator }

SnowSurfacePotential
^^^^^^^^^^^^^^^^^^^
{ snow_skin_potential_evaluator }


Generic Evaluators
---------------------------------

Several generic evaluators are provided.








InitialConditions
=================

Initial condition specs are used in two places -- in the PK_ spec
which describes the initial condition of primary variables, and in the
initial conditions sublist of state, in which the value of atomic
constants are provided.  In Amanzi, this list is also used for initial
conditions of primary variables are specified here, not within the PK
list (hence the name of this sublist).  In ATS, this sublist is pretty
much only used for constant scalars and constant vectors.

This list needs to be renamed -- it has nothing to do with inital conditions anymore.

Initialization of constant scalars
------------------------------------

A constant scalar field is the global (with respect to the mesh)
constant.  At the moment, the set of such fields includes atmospheric
pressure.  The initialization requires to provide a named sublist with
a single parameter `"value`".

.. code-block:: xml

  <ParameterList name="fluid_density">
    <Parameter name="value" type="double" value="998.0"/>
  </ParameterList>


Initialization of constant vectors
------------------------------------

A constant vector field is the global (with respect to the mesh)
vector constant.  At the moment, the set of such vector constants
includes gravity.  The initialization requires to provide a named
sublist with a single parameter `"Array(double)`". In two dimensions,
is looks like

.. code-block:: xml

  <ParameterList name="gravity">
    <Parameter name="value" type="Array(double)" value="{{0.0, -9.81}}"/>
  </ParameterList>


Initialization of scalar fields
------------------------------------

A variable scalar field is defined by a few functions (labeled for instance,
`"Mesh Block i`" with non-overlapping ranges. 
The required parameters for each function are `"region`", `"component`",
and the function itself.

.. code-block:: xml

  <ParameterList name="porosity"> 
    <ParameterList name="function">
      <ParameterList name="Mesh Block 1">
        <Parameter name="region" type="string" value="Computational domain"/>
        <Parameter name="component" type="string" value="cell"/>
        <ParameterList name="function">
          <ParameterList name="function-constant">
            <Parameter name="value" type="double" value="0.2"/>
          </ParameterList>
        </ParameterList>
      </ParameterList>
      <ParameterList name="Mesh Block 2">
        ...
      </ParameterList>
    </ParameterList>
  </ParameterList>


Initialization of tensor fields
------------------------------------
 
A variable tensor (or vector) field is defined similarly to a variable
scalar field.  The difference lies in the definition of the function
which is now a multi-values function.  The required parameters are
`"Number of DoFs`" and `"Function type`".

.. code-block:: xml

  <ParameterList name="function">
    <Parameter name="Number of DoFs" type="int" value="2"/>
    <Parameter name="Function type" type="string" value="composite function"/>
    <ParameterList name="DoF 1 Function">
      <ParameterList name="function-constant">
        <Parameter name="value" type="double" value="1.9976e-12"/>
      </ParameterList>
    </ParameterList>
    <ParameterList name="DoF 2 Function">
      <ParameterList name="function-constant">
        <Parameter name="value" type="double" value="1.9976e-13"/>
      </ParameterList>
    </ParameterList>
  </ParameterList>


Initialization from a file
------------------------------------

Some data can be initialized from files. Additional sublist has to be
added to named sublist of the `"state`" list with the file name and
the name of attribute.  For a serial run, the file extension must be
`".exo`".  For a parallel run, it must be `".par`".  Here is an
example:

.. code-block:: xml

  <ParameterList name="permeability">
    <ParameterList name="exodus file initialization">
      <Parameter name="file" type="string" value="mesh_with_data.exo"/>
      <Parameter name="attribute" type="string" value="perm"/>
    </ParameterList>
  </ParameterList>



example:

.. code-block:: xml

  <ParameterList name="state">
    <ParameterList name="initial conditions">
      <ParameterList name="fluid_density">
        <Parameter name="value" type="double" value="998.0"/>
      </ParameterList>

      <ParameterList name="fluid_viscosity">
        <Parameter name="value" type="double" value="0.001"/>
      </ParameterList>

      <ParameterList name="gravity">
        <Parameter name="value" type="Array(double)" value="{{0.0, -9.81}}"/>
      </ParameterList>

    </ParameterList>
  </ParameterList>




Time integrators, solvers, and other mathematical specs
####################################################################################

Common specs for all solvers and time integrators, used in PKs.


TimeIntegrator
=================

Linear Solver Spec
===================

For each solver, a few parameters are used:

* `"iterative method`" ``[string]`` `"pcg`", `"gmres`", or `"nka`"

  defines which method to use.

* `"error tolerance`" ``[double]`` **1.e-6** is used in the convergence test.

* `"maximum number of iterations`" ``[int]`` **100** is used in the convergence test.

* `"convergence criteria`" ``[Array(string)]``  **{{"relative rhs"}}** specifies multiple convergence criteria. The list
  may include `"relative residual`", `"relative rhs`", and `"absolute residual`", and `"???? force once????`"

* `"size of Krylov space`" ``[int]`` is used in GMRES iterative method. The default value is 10.

.. code-block:: xml

     <ParameterList name="my solver">
       <Parameter name="iterative method" type="string" value="gmres"/>
       <Parameter name="error tolerance" type="double" value="1e-12"/>
       <Parameter name="maximum number of iterations" type="int" value="400"/>
       <Parameter name="convergence criteria" type="Array(string)" value="{{relative residual}}"/>
       <Parameter name="size of Krylov space" type="int" value="10"/>

       <ParameterList name="VerboseObject">
         <Parameter name="Verbosity Level" type="string" value="high"/>
       </ParameterList>
     </ParameterList>


Preconditioner
===================

These can be used by a process kernel lists to define a preconditioner.  The only common parameter required by all lists is the type:

 * `"preconditioner type`" ``[string]`` **"identity"**, `"boomer amg`", `"trilinos ml`", `"block ilu`" ???
 * `"PC TYPE parameters`" ``[list]`` includes a list of parameters specific to the type of PC.

Example:

.. code-block:: xml

     <ParameterList name="my preconditioner">
       <Parameter name="type" type="string" value="trilinos ml"/>
        <ParameterList name="trilinos ml parameters"> ?????? check me!
            ... 
        </ParameterList>
     </ParameterList>


Hypre's Boomer AMG
-------------------
{ PreconditionerBoomerAMG }

Trilinos ML
-------------------
{ PreconditionerML }

Block ILU
-------------------
{ PreconditionerBlockILU }

Indentity
-------------------
The default, no PC applied.



NonlinearSolver
===================




Other Common Specs
##########################################

IOEvent
===================

{ IOEvent }

VerboseObject
===================

{ VerboseObject }
   

Function
===================

{ Function }

It is straightforward to add new functions as needed.

Constant Function
-------------------------
{ ConstantFunction }  

Tabular Function
-------------------------
{ TabularFunction }

Smooth step Function
-------------------------
{ SmoothStepFunction }

Polynomial Function
-------------------------
{ PolynomialFunction }  

Multi-variable linear Function
------------------------------
{ LinearFunction }  

Separable Function
------------------
{ SeparableFunction }

Additive Function
------------------
{ AdditiveFunction }

Multiplicative Function
--------------------------
{ MultiplicativeFunction }

Composition Function
--------------------------
{ CompositionFunction }

Piecewise Bilinear Function
---------------------------
{ BilinearFunction }

Distance Function
-------------------
{ DistanceFunction }

Monomial Function
-------------------
{ MonomialFunction }

Standard Math Function
-------------------------
{ StandardMathFunction }






